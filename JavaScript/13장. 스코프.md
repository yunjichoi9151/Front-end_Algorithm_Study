# 13. 스코프

## 13.1 스코프란?

**스코프*scope*(유효범위)**

모든 식별자( 변수, 함수, 클래스, etc..)는 자신이 선언된 위치로 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 결정된다. 이러한 유효범위를 스코프라고 한다.

**식별자 결정*identifier resolution***

js엔진은 스코프를 통해 어떤 변수를 참조해야 할 지를 결정한다.

즉, 스코프는 식별자를 검색할 때 사용하는 규칙이다.

```jsx
var x = "groval"; // x 선언, 모든 영역에서 사용가능, 전역 스코프

function foo() {
  var x = "local"; // foo에서 x 선언, foo 내부에서만 사용 가능, foo 함수 스코프
  console.log(x);
}
foo();

console.log(x);
// js엔진은 코드가 실행된 문맥을 고려한다.
```

**스코프는 네임스페이스**

식별자는 값을 구별해야 하므로 유일한 이름을 가져야 한다.

하지만, 같은 이름을 사용하지 못하면 이름 명명에 많은 스트레스를 받는다.

그래서 스코프를 이용해 변수 이름의 충돌을 방지하면서 같은 이름의 식별자를 사용할 수 있게한다.

```jsx
// 주의! var의 중복선언
// var는 같은 스코프 내에서 중복선언이 허용된다.
// 때문에 var는 의도치 않게 변수값이 재할당되는 부작용이 있다.
function foo() {
  var x = 1; // x을 var로 선언하고 1할당
  var x = 2; // x를 중복선언
  console.log(x); // 2
}
```

## 13.2 스코프의 종류

코드는 전역과 지역으로 구분한다.

| 구분 | 설명                  | 스코프      | 변수      |
| ---- | --------------------- | ----------- | --------- |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역 | 함수 몸체 내부        | 지역 스코프 | 지역 변수 |

변수는 자신이 선언된 위치로 스코프가 결정된다.

### 13.2.1 전역과 전역스코프

전역*global*은 코드의 가장 바깥 영역이다.

전역은 전역 스코프를 만들고 선언된 변수는 전역 스코프를 갖는 전역 변수가 된다.

전역 변수는 어디서든지 참조가 가능하다.

### 13.2.2 지역과 지역스코프

지역*local*은 함수 몸체 내부를 말한다.

지역은 지역 스코프를 만들고 선언된 변수는 지역 스코프를 갖는 지역 변수가 된다.

지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 참조가 가능하다.

```jsx
//전역변수와 지역변수의 예시

var x = "global scope x";
var y = "global scope y";

function foo() {
  var z = "local scope z";
  console.log(x); // global scope x
  console.log(y); // global scope y
  console.log(z); // local scope z
  function foo2() {
    var x = "local scope x";
    console.log(x); // local scope x
    console.log(y); // global scope y
    console.log(z); // local scope z
  }
  foo2();
}
foo();

console.log(x); // global scope x
console.log(y); // global scope y
console.log(z); // undefine error
```

## 13.3 스코프 체인

**함수의 중첩**

함수는 전역에서 정의할 수 있고, 함수 내부에서도 정의할 수 있다.

함수 내부에서 정의한 함수를 중첩함수*nested function*이라 하고,

중첩함수를 포함하는 함수를 외부함수*outer function*라고 한다.

**스코프의 중첩**

함수가 중첩된다는 것은, 함수의 지역스코프도 중첩된다는 뜻이다.

스코프는 함수의 중첩에 의해 게층적인 구조를 갖는다.

**스코프 체인*scope chain***

스코프는 하나의 계층적 구조로 연결된다.

모든 지역 스코프의 최상위 스코프는 전역 스코프가 된다.

이렇게 모든 스코프가 계층적으로 연결된 것을 스코프 체인이라고 한다.

js엔진은 변수를 참조할 때, 스코프 체인을 이용하는데,

참조된 코드의 스코프에서 시작해 상위 스코프 방향으로 이동하며 선언된 변수를 참조한다.

**스코프 체인의 물리적 구조**

스코프 체인은 물리적인 실체가 존재한다.

js엔진은 코드를 실행하기 전, 렉시컬 환경을 생성한다.

변수 선언이 실행되면 식별자가 렉시컬 환경에 키로 등록된다.

변수 할당이 일어나면 렉시컬 환경의 키에 해당하는 값을 변경한다.

변수의 검색도 렉시컬 환경에서 일어난다.

### 13.3.1 스코프 체인에 의한 변수 검색

js엔진은 변수를 참조하는 코드의 스코프에서 시작해 상위 스코프 방향으로 이동하며 검색한다.

절대 하위 스코프로 내려가면서 검색하는 경우는 없다.

이는, 상위 스코프의 변수를 하위 스코프에서는 자유롭게 참조가 되지만,

하위 스코프의 변수를 상위 스코프가 참조할 수 없음을 의미한다.

### 13.3.2 스코프 체인에 의한 함수 검색

js엔진은 함수를 선언하면 함수 이름과 동일한 이름의 식별자를 선언하고 함수를 할당한다.

즉, 함수도 식별자에 해당되기 때문에 스코프를 가지고 변수 검색과 동일하게 함수도 검색한다.

결론적으로 스코프는 식별자를 검색하는 규칙이다.

```jsx
//스코프 체인을 통한 검색 예시

var x = "global scope x";
var y = "global scope y";
// 전역 스코프에 선언된 x와 y

function foo() { // 지역 스코프에 foo함수와 변수 z가 선언되고
	var z = "local scope z";
	console.log(x);
	console.log(y);
	console.log(z);
	function foo2() {  // foo()의 중첩함수이거 하위 스코프에 선언된다.
		var x = "local scope x"
		console.log(x);
		console.log(y);
		console.log(z);
	foo2();
}
foo();

console.log(x); // global scope x
console.log(y); // global scope y
console.log(z); // undefine error
```

## 13.4 함수 레벨 스코프

지역 스코프는 코드 블록이 아닌 함수에 의해서 생성된다.

대부분의 언어는 모든 코드 블록(if, for, etc..)이 지역 스코프를 만든다.

하지만 var로 선언된 변수는 오로지 함수의 코드블록을 지역 스코프로 인정한다.

이를 함수 레벨 스코프*function level scope*라고 한다.

```jsx
var x = 10;

if (true) {
  var x = 100; // var는 함수 레벨 스코프라 if문을 지역 스코프로 인정하지 않는다
  // 따라서 x는 전역변수가 되고 x는 의도치 않은 중복선언이 되어 100이 들어간다.
}

console.log(x); // 100

for (var x = 0; x < 5; x++) {
  // for문 또한 함수가 아닌 코드블록이라 x가 재선언된다.
  consol.log(x); // 0 1 2 3 4
}

console.log(x); // 4
```

## 13.5 렉시컬 스코프

**동적 스코프와 렉시컬 스코프**

- 동적 스코프*dynamic scope* : 함수를 어디서 호출했는지로 상위 스코프를 결정
- 렉시컬 스코프*lexical scope* : 함수를 어디서 정의했는지로 상위 스코프를 결정

자바스크립트를 포함한 대부분의 언어는 렉시컬 스코프이다.
